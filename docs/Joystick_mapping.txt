From http://www.freelists.org/post/uae/Configuring-keymapping

A few people have asked about if it's possible to re-configure the keymapping 
in E-UAE. The answer is yes, but it's not easy to do, and it's not 
documented.

Note: the whole handling of key-press translation needs to be re-thought. I 
hacked in some code to support the translation of raw key codes, but it's 
pretty much a mess at the moment.

Anyway, I thought the easiest was to explain how this can be done now is with 
a couple of examples. You'll need to manually edit your config file.

Okay. Suppose (for some strange reason) you want the 'F1' key to produce the 
equivalent of pressing the 'A' key on an Amiga keyboard. You're running E-UAE 
on SDL/X11 on Linux, and you have raw key-mapping enabled 
(sdl.map_raw_keys=true).

The first thing you need to do is to enable an alternate input configuration. 
The default input configuration is number 0 and you can't modify that. You 
can, however, modify configs 1 to 4. So:

input.config=1

Now, you change the mapping of the F1 key with:

input.1.keyboard.0.button.67=KEY_A

The is saying for input config 1 (the configuration you enabled above), for 
keyboard 0 (the default), the button with keycode 67 will produce the input 
event "KEY_A".

67 is the "raw" X11 scan code for the F1 key on Linux when using PC or Mac 
keyboards. See the source file 'src/keymap/x11pc_rawkeys.c' for a list of 
these. See 'src/keymap/quartz_rawkeys.c' for the OS X codes. Etc.

The input events are listed in 'src/inputevents.def'. The first parameter in 
each DEFEVENT macro is the name of the input event.


Okay, let's try something more useful. Suppose you wanted to swap the left Alt 
and left Amiga keys. Do this with:

input.1.keyboard.0.button.64=KEY_AMIGA_LEFT
input.1.keyboard.0.button.115=KEY_ALT_LEFT


Note that input events that you can generate are not limited to Amiga 
key-presses. Suppose you want to emulate a joystick in port 2 with key 
presses:

# This enables WASD + Left alt joystick emulation
input.1.keyboard.0.button.25=JOY2_UP
input.1.keyboard.0.button.38=JOY2_LEFT
input.1.keyboard.0.button.39=JOY2_DOWN
input.1.keyboard.0.button.40=JOY2_RIGHT
input.1.keyboard.0.button.64=JOY2_FIRE_BUTTON

The equivalent for OS X would be:
input.1.keyboard.0.button.13=JOY2_UP
input.1.keyboard.0.button.0=JOY2_LEFT
input.1.keyboard.0.button.1=JOY2_DOWN
input.1.keyboard.0.button.2=JOY2_RIGHT
input.1.keyboard.0.button.58=JOY2_FIRE_BUTTON

If you select an inputdevice configuration other than config 0, then the 
existing default joystick emulation key layouts no longer apply. 

You have to add your own key-map option to emulate joystick input with the 
keyboard like the example I provided.

If you select an input config other config 0, then you have complete control 
over which input event is generated by which key. If you don't change 
anything, however, then the default mapping applies. Press 'a', you get an 
a', etc. As I said, the default joystick emulation options no longer work. You 
can select joyport1=kbd3, for example, but it will have no effect. The 't' 
kill will produce a 't' input event, unless you manually assign another event 
to the key.

Obviously if you you re-map a key, say 'W' to produce a joystick up event, 
then it cannot also produce a key 'w' event. Each key can be assigned only 
one event.


The reason for this system is to support two configuration modes. A legacy 
mode (input.confg=0) where you get the default key mapping, mapping of mouse 
and joystick events and the traditional keyboard joystick emulations; and a 
new mode, where you can configure everything yourself. In the new mode, you 
can configure 4 seperate mappings (input.config=<n>, where 1 <= n <= 4) which 
you can switch between easily.

